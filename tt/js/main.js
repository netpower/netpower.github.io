/*

>> kasperkamperman.com - 2018-04-18
>> kasperkamperman.com - 2020-05-17
>> https://www.kasperkamperman.com/blog/camera-template/

*/

//var takeSnapshotUI = createClickFeedbackUI();

var video;
var takePhotoButton;
var switchCameraButton;
var switchBeautyButton;
var switchStickerButton;
var switchLipButton;

var beautyOn  = 0;
var stickerOn = 0;
var lipOn = 0;
var amountOfCameras = 0;
var currentFacingMode = 'user';
var wasmLoaded = false;

var faceImgBuffer = null;
var faceImgBufferLength = 0;
var faceRGBBuffer = null;
var faceFrameBuffer = null;
var texture = null;
var mWidth  = 1280;
var mHeight = 720;
var textureId = null;
var canvasTimer = null;
var rendering = false;

const gl = document.getElementById('canvas').getContext("webgl");
// Only continue if WebGL is available and working
if (gl === null) {
    alert("Unable to initialize WebGL. Your browser or machine may not support it.");
}

//https://github.com/emscripten-core/emscripten/issues/6103
function RegisterNativeTextureId(textureResource)
{
    var id = GL.getNewId(GL.textures); // already included in code generated by emscripten
    textureResource.name = id;
    GL.textures[id] = textureResource;

    return id;
}

function UnregisterNativeTextureId(nativeTextureId)
{
    var tex = GL.textures[nativeTextureId];

    tex.name = 0;
    GL.textures[nativeTextureId] = null;

    return tex;
}

//帧率统计
var frameCnt = 0;
var timeElapsed = 0;
var lastTime = 0;
function calcFPS(){
    frameCnt++;

    let fps = 0;
    let timeDelta = 0;
    const currentTime = performance.now();

    if (lastTime) {
        timeDelta = currentTime - lastTime;
        fps = Math.round(1000/((currentTime - lastTime)));
    }
    lastTime = currentTime;
    timeElapsed +=timeDelta;

    if(timeElapsed >= 1000){
        fps = Math.round(frameCnt*1000/timeElapsed);
        timeElapsed = 0;
        frameCnt =0;
        console.log('FPS:'+fps);
    }
 }



// this function counts the amount of video inputs
// it replaces DetectRTC that was previously implemented.
function deviceCount() {
  return new Promise(function (resolve) {
    var videoInCount = 0;

    navigator.mediaDevices
      .enumerateDevices()
      .then(function (devices) {
        devices.forEach(function (device) {
          if (device.kind === 'video') {
            device.kind = 'videoinput';
          }

          if (device.kind === 'videoinput') {
            videoInCount++;
            console.log('videocam: ' + device.label);
          }
        });

        resolve(videoInCount);
      })
      .catch(function (err) {
        console.log(err.name + ': ' + err.message);
        resolve(0);
      });
  });
}

window.addEventListener("wasmLoaded", () => {
  console.log("wasmLoaded")
  wasmLoaded = true;
  if (
    navigator.mediaDevices &&
    navigator.mediaDevices.getUserMedia &&
    navigator.mediaDevices.enumerateDevices
  ) {
    // first we call getUserMedia to trigger permissions
    // we need this before deviceCount, otherwise Safari doesn't return all the cameras
    // we need to have the number in order to display the switch front/back button
    navigator.mediaDevices
      .getUserMedia({
        audio: false,
        video: true,
      })
      .then(function (stream) {
        stream.getTracks().forEach(function (track) {
          track.stop();
        });

        deviceCount().then(function (deviceCount) {
          amountOfCameras = deviceCount;
          Module._AEWebInit();
          let res = Module._AEWebCreateFaceHandle();
          console.log(res)
          Module._AEWebCreateBeautyEngine();
          beautyOn  = 1;
          initCameraUI();
          initCameraStream();
        });
      })
      .catch(function (error) {
        //https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
        if (error === 'PermissionDeniedError') {
          alert('Permission denied. Please refresh and give permission.');
        }

        console.error('getUserMedia() error: ', error);
      });
  } else {
    alert(
      'Mobile camera is not supported by browser, or there is no camera detected/connected',
    );
  }
});


document.addEventListener('DOMContentLoaded', function (event) {    
  var isStreaming = false;
  video = document.createElement("video");
  video.playsInline = true;
  video.muted = true;            
  canvas = document.getElementById('canvas');            
  canvasRaw = document.getElementById('canvasRaw');
  // Wait until the video stream canvas play
    video.addEventListener('canplay', function(e) {
        if (!isStreaming) {
            if (video.videoWidth > 0 && video.videoHeight > 0) {
                mWidth  = video.videoWidth;
                mHeight = video.videoHeight;
            }
            canvas.setAttribute('width', mWidth);
            canvas.setAttribute('height', mHeight);
            console.log("video size is:"+ video.videoWidth + "x" + video.videoHeight);
            console.log("set canvas size:"+ mWidth + "x" + mHeight);
            isStreaming = true;

            canvasRaw.setAttribute('width', mWidth);
            canvasRaw.setAttribute('height', mHeight);                    
        }
    }, false);
});

function initCameraUI() {
  //video = document.getElementById('video');
  takePhotoButton = document.getElementById('takePhotoButton');
  switchCameraButton = document.getElementById('switchCameraButton');
  switchBeautyButton = document.getElementById('switchBeautyButton');
  switchStickerButton = document.getElementById('switchStickerButton');
  switchLipButton = document.getElementById('switchLipButton');

  switchBeautyButton.disabled = false;
  switchStickerButton.disabled = false;
  switchLipButton.disabled = false;
  // https://developer.mozilla.org/nl/docs/Web/HTML/Element/button
  // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_button_role

  takePhotoButton.addEventListener('click', function () {
    //takeSnapshotUI();
    takeSnapshot();
  });

  switchBeautyButton.addEventListener('click', function () {
    if(beautyOn){
       beautyOn = 0;       
    }else{
      beautyOn = 1;
    }
    switchBeautyButton.setAttribute('aria-pressed',  beautyOn == 1);
  });

  switchStickerButton.addEventListener('click', function () {
    if(stickerOn){      
      stickerOn = 0;
    }else{
      stickerOn = 1;
    }
    Module._AEWebTestSticker(stickerOn == 1);
    switchStickerButton.setAttribute('aria-pressed', stickerOn == 1);
  });

  switchLipButton.addEventListener('click', function () {
    if(lipOn){
      lipOn = 0;      
    }else{
      lipOn = 1;
    }
    Module._AEWebEnableMakeup(0, lipOn == 1);
    switchLipButton.setAttribute('aria-pressed',     lipOn == 1);
  });
  switchBeautyButton.setAttribute('aria-pressed',  beautyOn == 1);
  switchStickerButton.setAttribute('aria-pressed', stickerOn == 1);
  switchLipButton.setAttribute('aria-pressed',     lipOn == 1);

  // -- switch camera part
  if (amountOfCameras > 1) 
  {
    switchCameraButton.style.display = 'block';

    switchCameraButton.addEventListener('click', function () {
      if (currentFacingMode === 'environment') currentFacingMode = 'user';
      else currentFacingMode = 'environment';

      initCameraStream();
    });
  }

  // Listen for orientation changes to make sure buttons stay at the side of the
  // physical (and virtual) buttons (opposite of camera) most of the layout change is done by CSS media queries
  // https://www.sitepoint.com/introducing-screen-orientation-api/
  // https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation
  window.addEventListener(
    'orientationchange',
    function () {
      // iOS doesn't have screen.orientation, so fallback to window.orientation.
      // screen.orientation will
      if (screen.orientation) angle = screen.orientation.angle;
      else angle = window.orientation;

      var guiControls = document.getElementById('gui_controls').classList;
      var vidContainer = document.getElementById('vid_container').classList;

      if (angle == 270 || angle == -90) {
        guiControls.add('left');
        vidContainer.add('left');
      } else {
        if (guiControls.contains('left')) guiControls.remove('left');
        if (vidContainer.contains('left')) vidContainer.remove('left');
      }

      //0   portrait-primary
      //180 portrait-secondary device is down under
      //90  landscape-primary  buttons at the right
      //270 landscape-secondary buttons at the left
    },
    false,
  );
}

// https://github.com/webrtc/samples/blob/gh-pages/src/content/devices/input-output/js/main.js
function initCameraStream() {
  // stop any active streams in the window
  if (window.stream) {
    window.stream.getTracks().forEach(function (track) {
      console.log(track);
      track.stop();
    });
    window.stream = null;
  }

  // we ask for a square resolution, it will cropped on top (landscape)
  // or cropped at the sides (landscape)
  var size = 1280;

  var constraints = {
    audio: false,
    video: {
      width: { ideal: size },
      height: { ideal: size },
      //width: { min: 1024, ideal: window.innerWidth, max: 1920 },
      //height: { min: 776, ideal: window.innerHeight, max: 1080 },
      facingMode: currentFacingMode,
    },
  };

  navigator.mediaDevices
    .getUserMedia(constraints)
    .then(handleSuccess)
    .catch(handleError);

  function handleSuccess(stream) {
    window.stream = stream; // make stream available to browser console
    video.srcObject = stream;

    if (constraints.video.facingMode) {
      if (constraints.video.facingMode === 'environment') {
        switchCameraButton.setAttribute('aria-pressed', true);
      } else {
        switchCameraButton.setAttribute('aria-pressed', false);
      }
    }

    const track = window.stream.getVideoTracks()[0];
    const settings = track.getSettings();
    str = JSON.stringify(settings, null, 4);
    console.log('settings ' + str);

    var videoW = settings.width;
    var videoH = settings.height;
    console.log("videoW:"+ videoW + " videoH:" + videoH);
    video.onloadedmetadata = function(e) {
        video.play();
        if(!rendering){
          render();
          rendering = true;
        }        
    };
  }

  function handleError(error) {
    console.error('getUserMedia() error: ', error);
  }
}

function render() {
  if (window.stream == null) {
      console.log('stream is null');
      requestAnimationFrame(render);
      return;
  }

  if (video == null) {
      console.log('video is null');
      return;
  }
  calcFPS();
  var canvasId  = 'canvas';
  var strBuffer = new TextEncoder().encode(canvasId);
  var strPointer = Module._malloc(strBuffer.length + 1);
  Module.HEAPU8.set(strBuffer, strPointer);
  Module.HEAPU8[strPointer + strBuffer.length] = 0;

  Module._AEWebMakeCurrent(strPointer);
  if (texture == null) {
      // Create texture
      console.log('texture is null, Create texture');
      texture = gl.createTexture();
      textureId = RegisterNativeTextureId(texture);

      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      // Initialize rendering
      gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
      gl.clearColor(0.0,0.0,0.0,1.0);
  }
  
  //console.log('texture:' + textureId);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

  // console.log('GL Error - 1: ' + gl.getError());
  detectFaceGL();
  // console.log('GL Error - 2: ' + gl.getError());
  Module._AERenderCameraImage(strPointer, textureId, beautyOn==0 );//
  // console.log('GL Error - 3: ' + gl.getError());
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, null);
  Module._free(strPointer);
  requestAnimationFrame(render);
}

function detectFaceGL (){
  try {
      var canvas = document.getElementById('canvas');
      var imageSize = canvas.width * canvas.height * 4;
      if (faceImgBufferLength != imageSize) {
          if (faceRGBBuffer != null) {
              faceRGBBuffer = null;                        
          }
          if (faceImgBuffer != null) {
              Module._free(faceImgBuffer);
              faceImgBuffer = null;
          }
          faceImgBufferLength = imageSize;
      }
      if (faceRGBBuffer == null) {
          faceRGBBuffer = new Uint8Array(faceImgBufferLength);                    
      }
      if (faceImgBuffer == null){
          faceImgBuffer = Module._malloc(faceImgBufferLength);
      }

      if (texture == null) {
          return;
      }
      const frameBuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);

      if (faceFrameBuffer == null) {
          faceFrameBuffer = gl.createFramebuffer();    
      }                
      gl.bindFramebuffer( gl.FRAMEBUFFER, faceFrameBuffer );
      gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0 );
      gl.readPixels(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight, gl.RGBA, gl.UNSIGNED_BYTE, faceRGBBuffer);

      //console.log(faceRGBBuffer);
      HEAPU8.set(faceRGBBuffer, faceImgBuffer);

      let count = Module._AEWebDetectFace(faceImgBuffer, canvas.width, canvas.height, 0, 0);
      gl.bindFramebuffer( gl.FRAMEBUFFER, frameBuffer);
      if (frameBuffer) {
          gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0 );    
      }
   } catch (e) {
     console.log(e);
   };            
}

function takeSnapshot() {
  // if you'd like to show the canvas add it to the DOM
  var canvas = document.createElement('canvas');

  var width = video.videoWidth;
  var height = video.videoHeight;

  canvas.width = width;
  canvas.height = height;

  context = canvas.getContext('2d');
  context.drawImage(video, 0, 0, width, height);

  // polyfil if needed https://github.com/blueimp/JavaScript-Canvas-to-Blob

  // https://developers.google.com/web/fundamentals/primers/promises
  // https://stackoverflow.com/questions/42458849/access-blob-value-outside-of-canvas-toblob-async-function
  function getCanvasBlob(canvas) {
    return new Promise(function (resolve, reject) {
      canvas.toBlob(function (blob) {
        resolve(blob);
      }, 'image/jpeg');
    });
  }

  // some API's (like Azure Custom Vision) need a blob with image data
  getCanvasBlob(canvas).then(function (blob) {
    // do something with the image blob
  });
}

// https://hackernoon.com/how-to-use-javascript-closures-with-confidence-85cd1f841a6b
// closure; store this in a variable and call the variable as function
// eg. var takeSnapshotUI = createClickFeedbackUI();
// takeSnapshotUI();

/*
function createClickFeedbackUI() {
  // in order to give feedback that we actually pressed a button.
  // we trigger a almost black overlay
  var overlay = document.getElementById('video_overlay'); //.style.display;

  // // sound feedback
  // var sndClick = new Howl({ src: ['snd/click.mp3'] });

  var overlayVisibility = false;
  var timeOut = 80;

  function setFalseAgain() {
    overlayVisibility = false;
    overlay.style.display = 'none';
  }

  return function () {
    if (overlayVisibility == false) {
      //sndClick.play();
      overlayVisibility = true;
      overlay.style.display = 'block';
      setTimeout(setFalseAgain, timeOut);
    }
  };
}
*/